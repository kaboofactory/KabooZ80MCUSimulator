; ============================================================================
; KabooZ80 Breakout (ブロック崩し) Sample
; ============================================================================
;
; このプログラムは、KabooZ80 MCU Simulator の周辺デバイス制御のデモです。
; 以下の機能を使用します：
; 1. Dot Matrix (16x16) : ゲーム画面の描画 (ポート 0x80-0x9F)
; 2. Keypad             : パドルの左右移動操作 (ポート 0x40)
;
; ■ ハードウェアマッピング解説
; 
; [Dot Matrix] (ポート 0x80 - 0x9F)
;  16x16 ドットマトリクスは、16行 x 16列のピクセルを持ちます。
;  各行は2つの8ビットポートで制御します。
;  - 行 N の左半分 (列 0-7) : ポート番号 0x80 + (行番号 * 2)
;  - 行 N の右半分 (列 8-15): ポート番号 0x80 + (行番号 * 2) + 1
;
; [Keypad] (ポート 0x40)
;  - 入力ポート 0x40 から押されたキーのコードを読み取ります。
;  - 何も押されていない場合は 0xFF が返ります。
;  - 今回は '4' (左移動) と '6' (右移動) を使用します。
;
; ============================================================================

; ----------------------------------------------------------------------------
; 定数定義 (CONSTANTS)
; ----------------------------------------------------------------------------
PORT_KEY    EQU 0x40        ; キーパッドのポート番号
PORT_MAT_BASE EQU 0x80      ; ドットマトリクスのベースポート番号

; キーコード (シミュレータのキーパッド配列に対応)
KEY_LEFT    EQU 4           ; '4' キー (左移動)
KEY_RIGHT   EQU 6           ; '6' キー (右移動)

; ゲーム設定
PADDLE_Y    EQU 15          ; パドルのY座標 (最下段: 15)
PADDLE_W    EQU 6           ; パドルの幅 (ピクセル数)

; ----------------------------------------------------------------------------
; 変数領域 (RAM)
; 通常 0xC000 以降をワークエリアとして使用します
; ----------------------------------------------------------------------------
    ORG 0xC000

BALL_X:     DB 0            ; ボールのX座標 (0-15)
BALL_Y:     DB 0            ; ボールのY座標 (0-15)
BALL_DX:    DB 0            ; ボールのX速度 (1:右へ, -1(255):左へ)
BALL_DY:    DB 0            ; ボールのY速度 (1:下へ, -1(255):上へ)
PADDLE_X:   DB 0            ; パドルの左端X座標 (0 ～ 16-PADDLE_W)
VRAM_BUF:   DS 32           ; ブロック情報を管理するメモリバッファ (32バイト)
                            ; 16行 x 2バイト = 32バイトですが、
                            ; 実際描画するのは上部4行(8バイト)のブロックのみ。
                            ; ここでビットを管理し、0なら空、1ならブロックありとします。

GAME_STATE: DB 0            ; ゲーム状態 (0:プレイ中, 1:ゲームオーバー 予備)

; ----------------------------------------------------------------------------
; プログラム開始 (CODE START)
; ----------------------------------------------------------------------------
    ORG 0x0000
START:
    LD SP, 0xFFFF           ; スタックポインタの初期化 (安全のため)

; ----------------------------------------------------------------------------
; 初期化処理 (INIT_GAME)
; ----------------------------------------------------------------------------
INIT_GAME:
    ; パドルの初期位置 (中央付近)
    LD A, 6
    LD (PADDLE_X), A
    
    ; ボールの初期位置
    LD A, 8
    LD (BALL_X), A
    LD A, 12
    LD (BALL_Y), A
    
    ; ボールの初期速度 (右下へ)
    LD A, 1
    LD (BALL_DX), A
    LD A, 255     ; -1 (2の補数表現)
    LD (BALL_DY), A
    
    ; ゲーム状態クリア
    XOR A
    LD (GAME_STATE), A

    ; ブロック(VRAM)の初期化
    ; 上部4行をすべてブロック(0xFF)で埋めます
    LD HL, VRAM_BUF
    LD B, 8       ; 4行 * 2バイト = 8バイト分
FILL_BRICKS:
    LD (HL), 0xFF ; すべてのビットを1にする
    INC HL
    DJNZ FILL_BRICKS
    
; ----------------------------------------------------------------------------
; メインループ (MAIN_LOOP)
; 1. 入力判定 -> 2. 物理演算 -> 3. 描画 を繰り返します
; ----------------------------------------------------------------------------
MAIN_LOOP:
    ; --- 1. 入力処理 ---
    IN A, (PORT_KEY)        ; キーパッドから入力読み込み
    CP 0xFF                 ; 0xFFなら入力なし
    JR Z, PHYS              ; 入力がなければ物理演算へ
    
    ; キー判定
    CP KEY_LEFT
    JR Z, MV_L              ; '4'なら左移動処理へ
    CP KEY_RIGHT
    JR Z, MV_R              ; '6'なら右移動処理へ
    JR PHYS                 ; その他のキーは無視

MV_L: ; 左移動
    LD A, (PADDLE_X)
    OR A                    ; A=0か？
    JR Z, PHYS              ; 既に左端(0)なら移動しない
    DEC A
    LD (PADDLE_X), A
    JR PHYS

MV_R: ; 右移動
    LD A, (PADDLE_X)
    CP 10                   ; 右端制限 (画面幅16 - パドル幅6 = 10)
    JR Z, PHYS              ; 既に右端なら移動しない
    INC A
    LD (PADDLE_X), A

PHYS:
    ; --- 2. 物理演算 (ボール移動・衝突判定) ---
    CALL DELAY_FRAME        ; ゲーム速度調整用ウェイト

    LD A, (GAME_STATE)
    OR A
    JR NZ, DRAW             ; ゲームオーバーなら更新しない(フリーズ)

    CALL UPDATE_BALL        ; ボールの位置更新と衝突判定

DRAW:
    ; --- 3. 描画処理 ---
    CALL VRAM_TO_MATRIX     ; メモリと変数の状態をハードウェアに出力
    JR MAIN_LOOP            ; 最初に戻る

; ----------------------------------------------------------------------------
; サブルーチン: ボールの更新 (UPDATE_BALL)
; ----------------------------------------------------------------------------
UPDATE_BALL:
    ; --- X軸の更新 ---
    LD A, (BALL_X)
    LD HL, BALL_DX
    ADD A, (HL)             ; X = X + DX
    LD (BALL_X), A
    
    ; 壁判定 (X)
    CP 0
    JR Z, BN_X_P            ; 左壁に当たった -> 右向き(正)反転
    CP 15
    JR Z, BN_X_N            ; 右壁に当たった -> 左向き(負)反転
    JR UPD_Y                ; 壁に当たってなければY軸処理へ

BN_X_P: ; X速度を +1 に
    LD A, 1
    LD (BALL_DX), A
    JR UPD_Y

BN_X_N: ; X速度を -1 に
    LD A, 255
    LD (BALL_DX), A

UPD_Y:
    ; --- Y軸の更新 ---
    LD A, (BALL_Y)
    LD HL, BALL_DY
    ADD A, (HL)             ; Y = Y + DY
    LD (BALL_Y), A
    
    ; 天井判定 (Y=0)
    CP 0
    JR Z, BN_Y_P            ; 天井に当たった -> 下向き(+1)反転
    
    ; パドル判定 (Y >= PADDLE_Y)
    CP PADDLE_Y
    JR NC, CHK_PAD          ; 最下段ならパドルとの衝突チェック
    
    ; ブロック判定
    CALL CHK_BRK            ; ブロックとの衝突チェック
    RET

BN_Y_P: ; Y速度を +1 に
    LD A, 1
    LD (BALL_DY), A
    RET

; パドルとの衝突判定 (CHK_PAD)
CHK_PAD:
    LD A, (BALL_X)          ; ボールのX
    LD B, A
    LD A, (PADDLE_X)        ; パドルの左端X
    SUB B                   ; パドルX - ボールX
    NEG                     ; ボールX - パドルX (パドル左端からの相対位置)
    
    ; ボールがパドルの幅(PADDLE_W)の中にいるか？
    ; 相対位置が 0 ～ (PADDLE_W - 1) ならヒット
    CP PADDLE_W
    JR C, PAD_HIT           ; キャリーフラグ(C)が立てばヒット (A < PADDLE_W)
    
    JP INIT_GAME            ; ミス！ ゲームリセットします
PAD_HIT:
    LD A, 255               ; 上向き(-1)に反転
    LD (BALL_DY), A
    RET

; ブロックとの衝突判定 (CHK_BRK)
CHK_BRK:
    LD A, (BALL_Y)
    CP 4                    ; Y < 4 のエリアがブロック領域
    RET NC                  ; 4以上ならブロックなし
    
    ; ブロックがあるかチェックして、あれば消します
    CALL CLR_BRK
    
    ; ブロックに当たったとしてY速度を反転 (簡易物理)
    LD A, (BALL_DY)
    NEG                     ; 符号反転
    LD (BALL_DY), A
    RET

; 指定位置のブロックを消去 (CLR_BRK)
CLR_BRK:
    ; VRAMのアドレス計算: VRAM_BUF + (BALL_Y * 2) [+1 if X>=8]
    LD A, (BALL_Y)
    ADD A, A                ; Y * 2
    LD C, A                 ; ベースオフセット
    
    LD A, (BALL_X)
    CP 8
    JR C, CB_L              ; X < 8 なら左バイト
    INC C                   ; X >= 8 なら右バイト (オフセット+1)
    SUB 8                   ; ビット計算用にXを 0-7 に正規化
    JR CB_DO
CB_L:
CB_DO:
    ; ここで A = ビット位置(0-7), C = VRAMオフセット
    LD B, A                 ; シフト回数
    
    ; マスク作成 (該当ビットだけ1、他0)
    LD A, 1
    OR A                    ; B=0チェック (シフト不要の場合)
    JR Z, SD
SL: SLA A                   ; 左シフト
    DJNZ SL
SD: CPL                     ; 反転 (該当ビットだけ0、他1)
    LD D, A                 ; マスクをDに保存
    
    ; メモリ読み書き
    LD HL, VRAM_BUF
    LD B, 0
    ADD HL, BC              ; アドレス決定
    LD A, (HL)
    AND D                   ; AND演算でビットを落とす(消去)
    LD (HL), A              ; 書き戻し
    RET

; ----------------------------------------------------------------------------
; 描画ルーチン (VRAM_TO_MATRIX)
; メモリ上のブロック情報、ボール座標、パドル座標を合成して
; ドットマトリクスの各行ポートに出力します。
; ----------------------------------------------------------------------------
VRAM_TO_MATRIX:
    LD B, 0                 ; 現在の行カウンタ (0-15)
    LD HL, VRAM_BUF         ; ブロックデータの参照ポインタ
RL: ; 行ループ開始 (Row Loop)
    PUSH BC                 ; B(行番号)を保存
    PUSH HL                 ; HL(ブロックポインタ)を保存
    
    ; --- 左側 (列 0-7) の描画データ作成 ---
    LD A, B
    CP 4                    ; 4行目未満か？
    JR NC, NB_L             ; 4行目以降はブロック無し(0)
    LD A, (HL)              ; ブロックデータをロード
    JR G_L
NB_L: XOR A                 ; ブロック無しエリアは0
G_L: LD D, A                ; Dレジスタに背景(ブロック)を描画
    
    ; ボール描画 (左側?)
    LD A, (BALL_X)
    CP 8
    JR NC, NBL_L            ; X >= 8 なら左には描画しない
    LD A, (BALL_Y)
    CP B                    ; 現在の行とボールのYが一致するか？
    JR NZ, NBL_L
    ; ボールあり -> ビットを立てる
    LD A, (BALL_X)
    CALL GBM                ; Get Bit Mask (1 << A)
    OR D                    ; 重ね合わせ
    LD D, A
NBL_L:
    
    ; パドル描画 (左側?)
    LD A, B
    CP 15                   ; 15行目(パドル位置)か？
    JR NZ, NP_L
    CALL ADD_P_L            ; パドルのビットを合成
NP_L:
    
    ; ポート出力 (左側)
    LD A, B                 ; 行番号
    ADD A, A                ; x2
    ADD A, 0x80             ; PORT_MAT_BASE(0x80)
    LD C, A                 ; ポートアドレス
    OUT (C), D              ; 出力！
    
    ; --- 右側 (列 8-15) の描画データ作成 ---
    POP HL                  ; HLを復帰して...
    INC HL                  ; 次のバイトへ進める(右側データ)
    PUSH HL                 ; また保存
    
    LD A, B
    CP 4
    JR NC, NB_R
    LD A, (HL)
    JR G_R
NB_R: XOR A
G_R: LD E, A                ; Eレジスタに右側の描画データ作成
    
    ; ボール描画 (右側?)
    LD A, (BALL_X)
    CP 8
    JR C, NBL_R             ; X < 8 なら右には描画しない
    LD A, (BALL_Y)
    CP B
    JR NZ, NBL_R
    ; ボールあり
    LD A, (BALL_X)
    SUB 8                   ; 0-7 に変換
    CALL GBM
    OR E
    LD E, A
NBL_R:

    ; パドル描画 (右側?)
    LD A, B
    CP 15
    JR NZ, NP_R
    CALL ADD_P_R
NP_R:

    ; ポート出力 (右側)
    LD A, B                 ; 行番号
    ADD A, A                ; x2
    ADD A, 0x81             ; 左ポート+1
    LD C, A
    OUT (C), E
    
    ; --- 次の行へ ---
    POP HL                  ; HL復帰
    INC HL                  ; 次の行の左側データへポインタを進める
    POP BC                  ; 行カウンタ復帰
    INC B                   ; 行を進める
    LD A, B
    CP 16                   ; 16行終わった？
    JP NZ, RL               ; まだならループ
    RET

; ----------------------------------------------------------------------------
; ユーティリティ: ビットマスク生成 (GBM: Get Bit Mask)
; 入力 A (0-7) に対し、(1 << A) を A に返します。
; ----------------------------------------------------------------------------
GBM:
    PUSH BC
    AND A           ; 入力Aが0かどうかチェック
    JR Z, GBM_ZERO  ; 0なら特別処理 (ループバグ回避)
    
    LD B, A         ; カウンタにセット
    LD A, 1         ; 初期値 1
GL: SLA A           ; 左シフト
    DJNZ GL         ; B回繰り返す
    POP BC
    RET
GBM_ZERO:
    LD A, 1         ; 0シフト = 1
    POP BC
    RET

; ----------------------------------------------------------------------------
; パドル描画ヘルパー (左側用)
; ----------------------------------------------------------------------------
ADD_P_L:
    PUSH BC         ; 親ルーチンのレジスタを保護
    LD B, PADDLE_W  ; パドル幅分ループ
    LD A, (PADDLE_X)
    LD C, A         ; 現在チェックするドットのX座標
APL_LOOP:
    LD A, C
    CP 8            ; X >= 8 (右側) になったら
    JR NC, APL_N    ; 左側には描かない
    
    ; 左側(0-7)内なので描画
    CALL GBM
    OR D            ; Dレジスタに合成
    LD D, A
APL_N:
    INC C           ; 次のピクセルへ
    DJNZ APL_LOOP   ; 幅分繰り返す
    POP BC          ; レジスタ復帰
    RET

; ----------------------------------------------------------------------------
; パドル描画ヘルパー (右側用)
; ----------------------------------------------------------------------------
ADD_P_R:
    PUSH BC
    LD B, PADDLE_W
    LD A, (PADDLE_X)
    LD C, A
APR_LOOP:
    LD A, C
    CP 8
    JR C, APR_N     ; X < 8 (左側) なら右には描かない
    
    ; 右側(8-15)内なので描画
    SUB 8           ; 0-7に変換
    CALL GBM
    OR E            ; Eレジスタに合成
    LD E, A
APR_N:
    INC C
    DJNZ APR_LOOP
    POP BC
    RET

; ----------------------------------------------------------------------------
; フレームウェイト (DELAY_FRAME)
; ゲーム速度調整用の空ループ
; ----------------------------------------------------------------------------
DELAY_FRAME:
    LD BC, 0x0800   ; 待ち時間カウント
DLPL: DEC BC
    LD A, B
    OR C
    JR NZ, DLPL
    RET
